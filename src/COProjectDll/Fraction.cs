using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace COProjectDll
{
    // класс дроби
    public class Fraction
    {
        /*********************** сначала описываем поля ******************/
        // Числитель
        // Автосвойство. Это как поле, только со своими особенностями.
        // Это упрощенная версия кода:
        // private numerator;
        // public GetNumerator();
        // public SetNumerator();
        // можно также не писать set; а оставить только get; 
        // тогда доступ к нему вне класса будет только на чтение
        public int Numerator { get; set; }

        // Знаменатель
        public int Denominator { get; set; }


        /****************************** конструкторы *************************/
        // Это называется конструктором
        // Он не  возвращает параметров
        // Нужен для инициализации класса при создании
        public Fraction()
        {
            Numerator = 0;
            Denominator = 1; // На ноль делить нельзя
        }

        // Это тоже конструктор. Он с параметрами.
        // В зависимости от того, как ты вызовешь конструктор (с параметрами или без)
        // вызовется либо 1 либо 2 конструктор
        public Fraction(int numerator, int denominator)
        {
            Numerator = numerator;
            if (denominator != 0) Denominator = denominator; // На ноль делить нельзя
            else Denominator = 1;

            // Resharper подчеркивает if зеленым (если ты его ставил).
            // если у тебя он установлен, то наводим на этот if и нажимаем alt+enter
            // выползет менюшка, где будет написано Convert to ?:
            // Попробуй, и скинешь мне результат)) я поясню что это такое позже))
            // иногда решарпер подчеркивает синим - можно так же навести на выделение и прожать alt+enter. 
            // Будут высвечиваться подсказки как улучшить код
        }

        /************************ методы **************************/
        // Метод сложения - кривая реализация, которую писать никогда не стоит, 
        // а лучше пользоваться операторами.
        // в качестве примера потянет
        public Fraction Summ(Fraction right)
        {
            // создаем дробь, которую вернем в качестве результата.
            // в данном случае для нее вызовется конструктор без параметров
            // можно написать и так 
            // Fraction result = new Fraction();
            // попробуй этот вариант и посмотри что скажет решарпер, а я пока оставлю так
            // var сделан для того чтобы не париться о типах))
            var result = new Fraction();

            // дело в том, что метод вызывается в экземпляре класса
            // в этот экземпляр мы передаем другую дробь.
            // метод сам означает следующее : "возьми дробь и прибавь ее к себе"
            // поэтому и изменяем числитель и знаменатель текущего класса
            // this - это ссылка на текущий экземпляр класса, в котором мы работаем. 
            // Его на самом деле можно не писать. для понимания я напишу его здесь, а дальше писать не буду
            // а *= b это тоже самое, что и a = a * b
            this.Denominator *= right.Denominator;
            this.Numerator = this.Numerator*right.Denominator + right.Numerator*this.Denominator;

            // возвращаем текущую дробь в качестве результата.
            // можно также и не писать тип возвращаемого значения, а написать void Summ(...)
            // тогда тут будет просто return;
            // класс все-равно поменяется!!!
            return this;
        }

        /**************************** операторы ****************************/
        // оператор +
        // он имеет спецификатор static
        // это значит что его можно использовать не создавая экземпляр класса.
        // здесь мы просто складываем right и left. 
        // Одако у нас уже есть метод сложения. Зачем писать его еще раз?
        // можно проще
        public static Fraction operator +(Fraction left, Fraction right)
        {
            //здесь вызовется 2 конструктор
            // на самом деле для этого случая нужно создать ещ отдельный конструктор копирования
            // куда будет передаваться 1 параметр типа Fraction
            // попробуй
            var res = new Fraction(left.Numerator, left.Denominator);

            res.Summ(right);

            // вот так вот легко))
            // здесь right и left не изменятся!!!
            return res;
        }

        // перебираемся в консольное приложение. я уже сделал его запускаемым))
        // ниже твой старый код
    }


    // это пишется не здесь. 
    // Класс это суность. Ей управляют. Сама она ничего не делает (в некотором смысле)
    /*
    class testProgramm
    {
        static void Main()
        {
            testClass example1 = new testClass(10, 5);
            example1.Summ();
            example1.Divided();
            example1.Print();
        }
    }*/


    // Сохранил твой старый код, чтобы ты сравнил и осознал
    /*
    class testClass
    {
        private int num1;
        private int num2;
        public int summ;
        public int divid;

        public testClass(int num1, int num2)
        {
            this.num1 = num1;
            this.num2 = num2;
        }

        public void Summ()
        {
            summ = num1+num2;
        }

        public void Divided()
        {
            divid=num1/num2;
        }

        public void Print()
        {
            Console.WriteLine("Сложение через метод:   {0} + {1} = {2}", num1, num2, summ);
            Console.WriteLine("Деление через метод:   {0} / {1} = {2}", num1, num2, divid);
            Console.WriteLine("Сложение через оператор:   {0} + {1} = {2}", num1, num2, num1 + num2);
            Console.WriteLine("Деление через оператор:   {0} / {1} = {2}", num1, num2, num1 / num2);
        }
    }
     * */
}
